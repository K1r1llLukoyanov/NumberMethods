
def seidel(A, B, e):    # метод Зейделя
    not_conds = []      # для хранения строки, в которой не преобладает диагональный элемент
    for i in range(len(A)): # проверяем строки
        sum = 0
        for j in range(len(A[i])):
            if j == i:
                continue
            sum += A[i][j]
        if (abs(sum) > abs(A[i][i])):
            not_conds.append((i, sum))  #   если сумма недиагональных элементов превосходит диагональный элемент, 
                                        #   дабавляем номер строки и их сумму в массив

    for i, s in not_conds: # пытаемся сделать диагональные элементы превосходящими(i - номер неправильной строки, s - сумма недиаг. элементов)
        for j in range(len(A)): # берем j-ую строку
            if i == j: # если номера строки которою нужно изменить совпадают с номером строки, которая будет использоваться для изменения
                continue # то пропускаем этот номер
            sum = 0
            for k in range(len(A[j])): # ищем сумму элементов элементов(кроме элемента i-ой колонны) строки
                if k == i:
                    continue
                sum += A[j][k]
            if (abs(A[j][i]) > abs(sum)): # если сумма этих элементов меньше чем i-ый элемент, то
                while abs(A[i][i]) < abs(s): # пока не получим превосходство диагонального элемента, выполняем цикл
                    s += sum
                    for h in range(len(A[i])):
                        A[i][h] += A[j][h] # прибавляем все элементы j-ой строки к элементам i-ой строки
                break

    X = [0 for _ in range(len(A))] # массив для неизвестных изначально заполненный нулями(первое приближение)

    while 1: # пока не достигнуто определенное значение точности
        Xp = X[:] # копируем все неизвестные в новый массив(понадобятся для оценки точности)
        for i in range(len(A)):
            b = B[i]
            for j in range(len(A[i])):
                if i == j:
                    continue
                b -= X[j]*A[i][j]   # вычитаем из свободного члена i-ой строки сумму неизвестных помноженных на коэффициенты(кроме i-го);
            X[i] = b/A[i][i]        # делим полученный результат на коэфф при i-ом элементе
        max = abs(X[0] - Xp[0])     # максимальная разница между предыдущим неизвестным и новым неизвестным
        for i in range(1, len(X)):  # проводим сравнение для всех парэлеметов
            if (abs(X[i]-Xp[i]) > max):
                max = abs(X[i] - Xp[i])
        if (max < e):               # если наибольшая разница между предыдущими элементами и текущими меньше погрешности, то
            break                   # останавливаем цикл
    return X


def main():
    A = [[0.3, 0.2, 0.1, 0.4], [0.3, 2.7, 0.1, 0.2],
         [0.1, 0.2, 2.9, 0.3], [0.1, 0.2, 0.2, 3.1]]
    B = [0.1, 0.2, 0.5, 0.8]
    e = 0.0001
    X = seidel(A, B, e)

    for i, v in enumerate(X):
        print("x{}) {}".format(i+1, v))

    print("Checking result:")

    for i in range(len(A)):
        print(B[i], end=' ')
        result = B[i]
        for j in range(len(A[i])):
            print("- {:.2f}*{}".format(X[j], A[i][j]), end=' ')
            result -= X[j]*A[i][j]
        print("= {:.3f}".format(result))


if __name__ == "__main__":
    main()
